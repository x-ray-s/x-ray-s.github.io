(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{356:function(e,t,a){e.exports=a.p+"assets/img/node-system.20c8ec0e.png"},357:function(e,t,a){e.exports=a.p+"assets/img/setImmediate-in-node.ade0fbcf.png"},449:function(e,t,a){"use strict";a.r(t);var r=a(23),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"page-title"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#page-title"}},[e._v("#")]),e._v(" "+e._s(e.$page.title))]),e._v(" "),r("h2",{attrs:{id:"时间并发模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#时间并发模型"}},[e._v("#")]),e._v(" 时间并发模型")]),e._v(" "),r("p",[e._v('JavaScript 的并发模型基于"事件循环"。')]),e._v(" "),r("h3",{attrs:{id:"栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[e._v("#")]),e._v(" 栈")]),e._v(" "),r("p",[e._v("函数调用形成了一个栈帧")]),e._v(" "),r("h3",{attrs:{id:"堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[e._v("#")]),e._v(" 堆")]),e._v(" "),r("p",[e._v("对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域")]),e._v(" "),r("h3",{attrs:{id:"队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[e._v("#")]),e._v(" 队列")]),e._v(" "),r("p",[e._v("一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都有一个为了处理这个消息相关联的函数。")]),e._v(" "),r("h3",{attrs:{id:"webapi-中的事件循环"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#webapi-中的事件循环"}},[e._v("#")]),e._v(" webapi 中的事件循环")]),e._v(" "),r("p",[e._v("协调用户界面，脚本，渲染，网络等等的事件，用户代理必须使用事件循环作为当前部分的描述，事件循环分为两类：一部分为了浏览上下文，一部分为了workers")]),e._v(" "),r("p",[e._v("一个浏览上下文事件模型总是需要至少一个浏览上下文。如果一个事件循环的浏览上下文结束，那么这个事件循环也随之结束。浏览上下文总是有一个事件循环来协调其活动。")]),e._v(" "),r("p",[e._v("worker 事件循环比较简单：每个worker都有一个事件循环，由worker进程模型管理事件循环的生命周期")]),e._v(" "),r("p",[e._v("一个事件循环有一个或多个任务队列。任务队列是一个有序的任务列表，它负责一下工作的算法：")]),e._v(" "),r("ul",[r("li",[e._v("事件")]),e._v(" "),r("li",[e._v("解析")]),e._v(" "),r("li",[e._v("回调")]),e._v(" "),r("li",[e._v("使用一个资源")]),e._v(" "),r("li",[e._v("响应dom操作")])]),e._v(" "),r("h3",{attrs:{id:"node-事件处理机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#node-事件处理机制"}},[e._v("#")]),e._v(" node 事件处理机制")]),e._v(" "),r("p",[e._v("先看下 node 中的事件处理机制")]),e._v(" "),r("p",[r("img",{attrs:{src:a(356),alt:"node system"}})]),e._v(" "),r("p",[e._v("一个事件循环的时间表")]),e._v(" "),r("p",[r("img",{attrs:{src:a(357),alt:"event loop schedules"}})]),e._v(" "),r("h2",{attrs:{id:"事件循环划分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件循环划分"}},[e._v("#")]),e._v(" 事件循环划分")]),e._v(" "),r("ul",[r("li",[e._v("Task(macroTask) "),r("code",[e._v("script")]),e._v(" "),r("code",[e._v("setTimeout")])]),e._v(" "),r("li",[e._v("MicroTask "),r("code",[e._v("promise")]),e._v(" "),r("code",[e._v("process.nextTick")]),e._v(" "),r("code",[e._v("setImmediate")])])]),e._v(" "),r("p",[e._v("先执行 task，后执行 mircoTask。")]),e._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop",target:"_blank",rel:"noopener noreferrer"}},[e._v("并发模型与事件循环"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Tasks, microtasks, queues and schedules"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/",target:"_blank",rel:"noopener noreferrer"}},[e._v("The Node.js Event Loop, Timers, and process.nextTick()"),r("OutboundLink")],1)]),e._v(" "),r("p",[r("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop",target:"_blank",rel:"noopener noreferrer"}},[e._v("webapi Event loops"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);